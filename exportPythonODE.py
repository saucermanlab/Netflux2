# exportPythonODE.py
# 1/20/2025 by Jeff Saucerman
# replicates features of exportPythonODE.m and Netflux2PythonODE.m
# STATUS: tested using exampleNet.xlsx, working
import numpy as np
import datetime

def writeModel(model):
    writeParamsFile(model)
    writeRunFile(model)
    writeODEfile(model)

def writeParamsFile(model):
    # Takes an LDEmodel and writes modelName_params.py, which will be loaded
    # by modelName_run.py
    
    fname = str(model.modelName) + "_params.py"
    with open(fname, "w") as file:
        file.write(f"# {fname}\n")
        file.write(f"# Automatically generated by Netflux2 on {datetime.date.today()}\n")
        file.write("import numpy as np\n\n")
        file.write("def loadParams():\n")
        file.write("    # species parameters\n")
        file.write(f"    speciesIDs = {model.speciesIDs.tolist()}\n") 
        y0 = model.speciesParams.iloc[:,0].tolist()
        ymax = model.speciesParams.iloc[:,1].tolist()
        tau = model.speciesParams.iloc[:,2].tolist()
        file.write(f"    y0 = np.array({y0})\n")
        file.write(f"    ymax = np.array({ymax})\n")
        file.write(f"    tau = np.array({tau})\n\n")
        file.write("    # reaction parameters\n")
        w = model.reactionParams.iloc[:,0].tolist()
        n = model.reactionParams.iloc[:,1].tolist()
        EC50 = model.reactionParams.iloc[:,2].tolist()
        file.write(f"    w = np.array({w})\n")
        file.write(f"    n = np.array({n})\n")
        file.write(f"    EC50 = np.array({EC50})\n\n")
        file.write("    return speciesIDs, y0, ymax, tau, w, n, EC50")
        
def writeRunFile(model):
    # Takes an LDEmodel and writes modelName_run.py, which runs the simulation
    
    fname = str(model.modelName) + "_run.py"
    with open(fname, "w") as file:
        file.write(f"# {fname}\n")
        file.write(f"# Automatically generated by Netflux2 on {datetime.date.today()}\n")
        file.write("import numpy as np\n")
        file.write("from scipy.integrate import solve_ivp\n")
        file.write("import matplotlib.pyplot as plt\n")
        file.write(f"import {model.modelName}\n")
        file.write(f"import {model.modelName}_params\n\n")
        file.write(f"speciesNames, y0, ymax, tau, w, n, EC50 = {model.modelName}_params.loadParams()\n\n")        
        file.write("# Run single simulation\n")
        file.write("tspan = [0, 10]\n")
        file.write(f"solution = solve_ivp({model.modelName}.ODEfunc, tspan, y0, args=(ymax, tau, w, n, EC50))\n\n")
        file.write("fig, ax = plt.subplots()\n")
        file.write("ax.plot(solution.t,solution.y.T)\n")
        file.write("ax.set(xlabel='Time',ylabel='Normalized activity')\n")
        file.write("ax.legend(speciesNames)")

def writeODEfile(model):
    # writes the ODEfile consisting of LDEs, called by modelName_run.py
    
    fname = model.modelName + ".py"
    with open(fname, "w") as file:
        file.write(f"# {fname}\n")
        file.write(f"# Automatically generated by Netflux2 on {datetime.date.today()}\n")
        file.write("import numpy as np\n\n")
        file.write("def ODEfunc(t,y,ymax,tau,w,n,EC50):\n\n")

        # name the indices by speciesID
        file.write("    # network species\n")
        for i, speciesID in enumerate(model.speciesIDs):
            file.write(f"    {speciesID} = {i}\n")

        file.write("\n    # logic-based differential equaations\n")
        file.write(f"    dydt = np.zeros({i+1})\n")      
        for i, speciesID in enumerate(model.speciesIDs):
            rcnString = getReactionString(model,i) # TODO TEMP; working on getReactionString, might also need to modify ymax??
            file.write(f"    dydt[{speciesID}] = ({rcnString}*ymax[{speciesID}] - y[{speciesID}])/tau[{speciesID}]\n")
        file.write("\n    return dydt\n")
        
        file.write(returnUtilityFunctions()) # writes the AND/OR/fact/finhib functions

def getReactionString(model,speciesID):
    # generates strings for the reactions for which speciesID is a product
    # utility function for writeODEfile

    # find reactions where speciesID is a product
    intMat = model.interactionMatrix
    notMat = model.notMatrix
    rcnsWhereSpeciesIsProduct = np.where(intMat[speciesID, :] == 1)[0].tolist()
    
    # loop over rcnsWhereSpeciesIsProduct to generate rcnStringList
    rcnStringList = []
    for rcnID in rcnsWhereSpeciesIsProduct:
        reactantIndices = np.where(intMat[:,rcnID] == -1)[0].tolist() 
        if len(reactantIndices) == 0:           # input reaction, no reactants
            rcnStringList.append(f"w[{rcnID}]")
 
        elif len(reactantIndices) == 1:         # single reactant
            reactant = reactantIndices[0]
            if notMat[reactant,rcnID] == 0: # reactant is activating            
                rcnStringList.append(f"act(y[{model.speciesIDs[reactant+1]}],w[{rcnID}],n[{rcnID}],EC50[{rcnID}])")
            else:                                   # reactant is inhibiting
                rcnStringList.append(f"inhib(y[{model.speciesIDs[reactant+1]}],w[{rcnID}],n[{rcnID}],EC50[{rcnID}])")
        
        else:                                   # loop over reactants for AND gate
            rcnString = []
            for reactant in reactantIndices:    # multiple reactants 
                 if notMat[reactant,rcnID] == 0: # reactant is activating            
                     rcnString.append(f"act(y[{model.speciesIDs[reactant+1]}],w[{rcnID}],n[{rcnID}],EC50[{rcnID}])")
                 else:                                   # reactant is inhibiting
                     rcnString.append(f"inhib(y[{model.speciesIDs[reactant+1]}],w[{rcnID}],n[{rcnID}],EC50[{rcnID}])")
                     rcnStringList.append("*".join(rcnString))

    # combine reactions with OR gates
    if len(rcnStringList) == 1:
        rcnString = rcnStringList[0]
    else:
        rcnString = nestedOR(rcnStringList)
        
    return rcnString

def nestedOR(items):    # thanks Copilot!
    if len(items) == 1:
        return items[0]
    else:
        return f"OR({items[0]},{nestedOR(items[1:])})"
        
def returnUtilityFunctions():
    # called by writeODEfile
    
    utilityFunctionText = """
# utility functions
def act(x, w, n, EC50):
    # hill activation function with parameters w (weight), n (Hill coeff), EC50
    beta = ((EC50**n)-1)/(2*EC50**n-1)
    K = (beta-1)**(1/n)
    fact = w*(beta*x**n)/(K**n+x**n)
    if fact > w:
        fact = w
    return fact

def inhib(x, w, n, EC50):
    # inverse hill function with parameters w (weight), n (Hill coeff), EC50
    finhib = w - act(x, w, n, EC50)
    return finhib

def OR(x, y):
    # OR logic gate
    z = x + y - x*y
    return z

def AND(w, reactList):
    # AND logic gate, multiplying all of the reactants together
    if w == 0:
        z = 0
    else:
        p = np.array(reactList).prod()
        z = p/w**(len(reactList)-2)
    return z
"""    
    return utilityFunctionText
        




